-- Migration 030: Identity Verification (Provider-Agnostic)
-- Adds verified_at + updated_at to auth.identities
-- Migrates email_confirmed_at data from auth.users
-- Installs Iron-Clad trigger for enterprise-grade immutability

BEGIN;

-- 1. Add new columns
ALTER TABLE auth.identities
    ADD COLUMN IF NOT EXISTS verified_at TIMESTAMPTZ,
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ;

-- 2. Migrate existing verification data (email identities inherit from users.email_confirmed_at)
UPDATE auth.identities i
SET verified_at = u.email_confirmed_at
FROM auth.users u
WHERE i.user_id = u.id
  AND i.provider = 'email'
  AND u.email_confirmed_at IS NOT NULL
  AND i.verified_at IS NULL;

-- 3. IRON-CLAD TRIGGER: Universal Security Lock (Defense-in-Depth)
-- Enforces at the DATABASE LAYER (impossible to bypass from application code):
--   id:          IMMUTABLE (frozen on update)
--   created_at:  IMMUTABLE (frozen on update)
--   verified_at: WRITE-ONCE SEAL (once set, permanently sealed â€” cannot be overwritten or cleared)
--   updated_at:  SERVER-CONTROLLED (forced to now() on every update, never client-spoofable)
CREATE OR REPLACE FUNCTION auth.lock_identities_integrity()
RETURNS TRIGGER AS $$
BEGIN
    -- IMMUTABLE: id can never be changed
    NEW.id = OLD.id;
    -- IMMUTABLE: created_at frozen at birth
    NEW.created_at = OLD.created_at;
    -- WRITE-ONCE SEAL: verified_at, once stamped, is permanent evidence
    IF OLD.verified_at IS NOT NULL THEN
        NEW.verified_at = OLD.verified_at;
    END IF;
    -- SERVER-CONTROLLED: updated_at always reflects true server time
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS ensure_identities_integrity ON auth.identities;
CREATE TRIGGER ensure_identities_integrity
BEFORE UPDATE ON auth.identities
FOR EACH ROW EXECUTE FUNCTION auth.lock_identities_integrity();

COMMIT;
