#!/bin/sh
# ============================================================
# Phantom Linker — Hot Extension Injection for PostgreSQL
# ============================================================
# Este script roda em background dentro do container do Postgres.
# Ele monitora o diretório /cascata_extensions (volume Docker
# compartilhado) e cria symlinks no diretório oficial de libs
# do PostgreSQL quando novas extensões são detectadas.
#
# O Postgres carrega .so files on-demand no CREATE EXTENSION,
# então não precisa de restart para extensões normais.
#
# Extensões que exigem shared_preload_libraries (pg_cron,
# pg_stat_statements) são tratadas no Dockerfile, não aqui.
# ============================================================

set -e

# Diretórios oficiais do PostgreSQL no Alpine
PG_LIB="/usr/local/lib/postgresql"
PG_SHARE="/usr/local/share/postgresql/extension"

# Diretório de staging (volume compartilhado com o backend)
EXT_LIB="/cascata_extensions/lib"
EXT_SHARE="/cascata_extensions/share"
EXT_OS_LIB="/cascata_extensions/os_lib"

# Arquivo de lock para evitar race conditions
LOCK_FILE="/tmp/phantom_linker.lock"

# Contadores para logging
LINKED_COUNT=0

sync_extensions() {
    # Previne execuções concorrentes
    if [ -f "$LOCK_FILE" ]; then
        return 0
    fi
    touch "$LOCK_FILE"

    local new_links=0

    # Link .so files (shared objects - código compilado da extensão)
    if [ -d "$EXT_LIB" ]; then
        for f in "$EXT_LIB"/*.so "$EXT_LIB"/*.so.*; do
            [ -f "$f" ] || continue
            base=$(basename "$f")
            target="$PG_LIB/$base"
            if [ ! -e "$target" ]; then
                ln -sf "$f" "$target"
                new_links=$((new_links + 1))
                echo "[PhantomLinker] Linked library: $base"
            fi
        done
    fi

    # Link dependências Nativas de OS (ex: libgeos_c.so.1, libpcre2-8.so, libsqlite3.so.0)
    # MUST run BEFORE share linking — once .control files are linked,
    # pg_available_extensions reports the extension as available, and
    # ExtensionService may immediately fire CREATE EXTENSION.
    # If OS deps aren't in place yet, it fails with "No such file or directory".
    if [ -d "$EXT_OS_LIB" ]; then
        for f in "$EXT_OS_LIB"/*.so "$EXT_OS_LIB"/*.so.*; do
            [ -f "$f" ] || continue
            base=$(basename "$f")
            target="/usr/lib/$base"
            if [ ! -e "$target" ]; then
                ln -sf "$f" "$target"
                new_links=$((new_links + 1))
                echo "[PhantomLinker] Linked OS Dependency: $base"
            fi
        done
    fi

    # Link .control files (metadados da extensão) e .sql files (DDL)
    # This MUST be LAST — once .control is symlinked, PostgreSQL sees the extension
    # in pg_available_extensions and the backend may immediately try CREATE EXTENSION.
    if [ -d "$EXT_SHARE" ]; then
        for f in "$EXT_SHARE"/*; do
            [ -f "$f" ] || continue
            base=$(basename "$f")
            target="$PG_SHARE/$base"
            if [ ! -e "$target" ]; then
                ln -sf "$f" "$target"
                new_links=$((new_links + 1))
            fi
        done
    fi

    if [ "$new_links" -gt 0 ]; then
        LINKED_COUNT=$((LINKED_COUNT + new_links))
        echo "[PhantomLinker] Sync complete. $new_links new files linked (total: $LINKED_COUNT)"
    fi

    rm -f "$LOCK_FILE"
}

# Função para remover symlinks órfãos (extensão removida do volume)
cleanup_orphans() {
    # Limpa links simbólicos quebrados no diretório de libs
    for link in "$PG_LIB"/*; do
        [ -L "$link" ] || continue
        if [ ! -e "$link" ]; then
            echo "[PhantomLinker] Removing orphan link: $(basename "$link")"
            rm -f "$link"
        fi
    done

    for link in "$PG_SHARE"/*; do
        [ -L "$link" ] || continue
        if [ ! -e "$link" ]; then
            rm -f "$link"
        fi
    done

    # Limpa OS links quebrados
    for link in /usr/lib/*; do
        [ -L "$link" ] || continue
        # Target starts with /cascata_extensions/os_lib
        if [ "$(readlink "$link" | grep -c "^$EXT_OS_LIB")" -gt 0 ] && [ ! -e "$link" ]; then
            echo "[PhantomLinker] Removing orphan OS link: $(basename "$link")"
            rm -f "$link"
        fi
    done
}

# ============================================================
# MAIN EXECUTION
# ============================================================

echo "[PhantomLinker] Starting Phantom Extension Linker v1.0"
echo "[PhantomLinker] Monitoring: $EXT_LIB, $EXT_SHARE, $EXT_OS_LIB"
echo "[PhantomLinker] Target: $PG_LIB, $PG_SHARE, /usr/lib"

# Sync inicial no boot (extensões previamente injetadas)
sync_extensions

# Watch loop usando inotifywait (instalado no Dockerfile)
if command -v inotifywait >/dev/null 2>&1; then
    echo "[PhantomLinker] Using inotify mode (real-time detection)"
    while true; do
        # Monitora criação e movimentação de arquivos nos diretórios de staging
        # --timeout 60: Também faz um sync a cada 60 segundos como fallback
        inotifywait -r -q --timeout 60 \
            -e create,moved_to,delete \
            "$EXT_LIB" "$EXT_SHARE" "$EXT_OS_LIB" 2>/dev/null || true
        
        
        # Pequeno delay para garantir que todas as escritas terminaram
        # (imagens Docker copiam múltiplos arquivos em sequência)
        sleep 2
        sync_extensions
        cleanup_orphans
    done
else
    # Fallback: polling a cada 10 segundos (caso inotify-tools não esteja instalado)
    echo "[PhantomLinker] WARNING: inotify-tools not found, using polling mode (10s)"
    while true; do
        sleep 10
        sync_extensions
        cleanup_orphans
    done
fi
